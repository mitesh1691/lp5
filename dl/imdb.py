# -*- coding: utf-8 -*-
"""IMDB

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PX3Db_WywzoKW0tlJLBTTIbDjPZoXgDX
"""

import numpy as np
from keras.datasets import imdb
from keras.preprocessing.sequence import pad_sequences
from keras.models import Sequential
from keras.layers import Dense
import matplotlib.pyplot as plt

# Load the IMDB dataset with a larger vocabulary size
max_features = 10000
(X_train, y_train), (X_test, y_test) = imdb.load_data(num_words=max_features)

# Get the word index mapping
word_index = imdb.get_word_index()

# Reverse the word index mapping to decode the reviews
reverse_word_index = {index: word for word, index in word_index.items()}

# Decode a sample review
decoded_review = ' '.join([reverse_word_index.get(word_index - 3, '?') for word_index in X_train[0]])

print("Decoded Review:")
print(decoded_review)

# Preprocess the data: Pad sequences to ensure uniform length
maxlen = 10000  # Update the maxlen to match the expected input shape
X_train = pad_sequences(X_train, maxlen=maxlen)
X_test = pad_sequences(X_test, maxlen=maxlen)

# Define the model
model = Sequential([
    Dense(16, activation='relu', input_shape=(10000,)),
    Dense(16, activation='relu'),
    Dense(1, activation='sigmoid')
])

# Compile the model
model.compile(optimizer='rmsprop',
              loss='binary_crossentropy',
              metrics=['accuracy'])

# Train the model
history = model.fit(X_train, y_train, epochs=10, batch_size=512, validation_split=0.2)

# Predictions on sample reviews from the test set
sample_reviews = X_test[:5]
sample_labels = y_test[:5]

# Perform predictions
predictions = model.predict(sample_reviews)

# Map predictions to human-readable labels
predicted_labels = ["Positive" if pred >= 0.5 else "Negative" for pred in predictions]

# Display the actual reviews, actual labels, and predicted labels
for i, (review, actual_label, predicted_label) in enumerate(zip(sample_reviews, sample_labels, predicted_labels), 1):
    print(f"\nReview {i}:")
    print(f"Actual Label: {'Positive' if actual_label == 1 else 'Negative'}")
    print(f"Predicted Label: {predicted_label}")

# Evaluate the model on the test set
loss, accuracy = model.evaluate(X_test, y_test)
print("\nTest Loss:", loss)
print("Test Accuracy:", accuracy)

# Get training and validation accuracy from history
train_accuracy = history.history['accuracy']
val_accuracy = history.history['val_accuracy']

# Plot training and validation accuracy
epochs = range(1, len(train_accuracy) + 1)
plt.plot(epochs, train_accuracy, 'bo', label='Training accuracy')
plt.plot(epochs, val_accuracy, 'b', label='Validation accuracy')
plt.title('Training and validation accuracy')
plt.xlabel('Epochs')
plt.ylabel('Accuracy')
plt.legend()
plt.show()